# C++ Learning
*base on cs106l spring 2023*
***
## Lec1.Basic Intro
**重点：** ***what's cpp?***

**Ans:** ***基本语法 + STL***

+ 基本语法：语句末的分号，原始的类型(int,double)，基本语法规则  
+ the STL：大量的功能， 内置的类(maps,vectors)，通过***std::***命名空间实现


### Namespaces
+ 命名空间，许多功能都实现在***std::***中，靠它来引入
+ 通常会使用***using namespace std;***在开头，这样可以自动为*cin*,*cout*等增加*std::*前缀来使用，但**cs106l并不推荐这种写法**
###STL
+ 全称**标准模板库(Standard Template Library)**，包含大量功能(算法，容器，函数，迭代器)
+ STL的命名空间为*std*，是standard的缩写
+ 要从STL访问元素（其实跟调用函数差不多）要用***std::***

## Lec2.Types and Structs
### Fundamental Types 基本类型
+ int, char, float, double, bool
+ std::string(#include <string\>)
### C++是一种静态语言(*statically typed*)
+ 所有有名字的东西（函数，变量等）在运行前都会被赋予一个类型
+ 源码编译发生在程序运行前
+ 与之相反，动态语言(***dynamically typed***)如python会在运行时根据值来赋予其类型，逐行运行与编译，因此可能在运行中会遇到不可预知的错误
+ 所以静态类型能帮助**在程序运行前预防错误**
###函数重载
+ 可以同名，但变量类型不能相等
###struct：一种将不同的types捆绑在一起的方法
+ 可以用struct传递一组数据，同样的，也可以使返回一组数据
+ 初始化方法：  
    1.定义后创建，创建后逐项初始化  
    2.定义后创建，直接{}大括号括起来，像数组那样初始化
+ ***std::pair：***STL提供的模板，用于结合两个类型  
> std::pair <type1, type2\> pairName = {data1, data2};  
----------引用STL库---------- | ----------------初始化---------------|  

前者通过*.first*引用，后者通过*.second*引用  
当返回**pair**时，若不想显式的定义出/懒得打字，可以使用
> std::make_pair(field1, field2)  

来隐式的调用它了  

### auto：方便的自动推理type
+ 用来代替变量前的type，让编译器自己推导类型  
+ **不意味着变量没有类型**，只是简化
+ **适当**的使用能使代码变得**简洁**，**过度**的使用反而会**降低可读性甚至错误**。应该在前面或其他地方经过充分的定义才能使编译器推导出类型。

##Lec3.Init & Reference 初始化与引用
###初始化：为变量提供一个初始的值
+ 初始化可以有多种方式：  
    1.先创建变量，再赋予其值(*int a; a = 0;*)  
    2.创建变量的时候直接赋予其值(*int a= 0;*)  
    3.拥有特殊初始化手段，譬如STL或函数(*std::pair<int, string\> a = std::make_pair(1, "a")*)  
+ 最统一的初始化：**花括号{}**，无论什么类型都可以用花括号来进行初始化。**尽管**有时*普通括号()*与括号因特性会与*花括号{}*拥有相同的效果，**但是**在*std::vector<>*
向量的初始化时，*{}*与*()*十分不同
>std::vector<int\> vec1(3, 5);  
>std::vector<int\> vec2{3, 5};  

    其中，**vec1 = {5, 5, 5}**，**vec2 = {3, 5}**  

### 进阶技巧：基于auto与pair实现结构化绑定(Structured binding)
+ 以*pair*为例， 得到的pair在**初始化时**是有条理的：  
>auto p = std::make_pair("str", 1);  

    而在**赋予其他变量时**却只能一个一个的赋予，反而失去了条理：  
>string str = p.first;  
int num = p.second;  

    纵使pair本身有*.first*与*.second*的逻辑关系，但分两行写又使没有那么清晰，所以有这样的结构化绑定：  
>auto [str, num] = p;  

    十分清晰了。  

+ 放在长串代码里更能体会：  

    auto result = fun(a, b, c);  
    bool ifFound = result.first;  
    if (ifFound)  
    {  
        auto solutions = result.second;  
        std::cout << solutions.first << solutions.second << endl;  
    }  
    else  
    {  
        std::cout << "Can't Found" << endl;  
    }  

    结构化绑定后：

    auto result = fun(a, b, c);  
    auto [ifFound, solutions\] = result;  
    if (ifFound)  
    {  
        auto [x1, x2\] = solutions;  
        std::cout << x1 << x2 << endl;  
    }  
    else  
    {  
        std::cout << "Not Found" << endl;  
    }  

    ***显然更为的整洁易懂。***  

+ 注意，结构化绑定时获得的是**复制**，而非**引用**，要对值进行修改时注意**引用**，见下方。

### 引用：已经拥有的变量的别名
+ 引用不同与值传递与地址传递：
    1.值传递：原来的a->复制一份成为b->对b进行操作i->最后a没有变，b变了。  
    2.地址传递：原来的a->得出a的地址a'->对a'进行解地址操作->最后改变的还是a。  
    3.引用：原来的a->进行一个引用出b->实际上a与b就是一个东西。  

+ 引用的例子：

    int a = 100;  
    int & b = a;//a成为b的引用  
    b = 0;  

    实际上a就是b，变为0了。  

+ 典型的忽略引用bug：  

    auto [num1, num2\] = nums[i\];  
    num1 ++;  
    num2 ++;  

    在向量（高端数组）的一个循环中，利用上述的结构化绑定技巧，却没有注意到这样的赋值只是给复制进行了操作i，而并没有给要操作的本身进行操作。往往只在函数定义时关注***复制还是引用***的问题，在函数实现的代码中就没有这么做。修改：  

    auto& [num1, num2\] = nums[i\];  

    即可。  
    ***所以，结构化绑定时要注意引用！***

### 左值、右值
+ 左值可以在**等号=**的左边被赋值，也可以在等号右边赋予别的变量值。是一个有自己的**名字**的**非临时值**。譬如平时定义的变量。  
+ 右值是一个没有名字的临时量，只能在等号右边给别的值赋值。  
比如：  
> int x = 1;  
    
    其中x为左值，1为右值。  

+ **只有左值才能被引用**。  

### const 修饰的变量
+ const表示变量**不能够被修改**。  
+ 那么const与引用的关系？  
    **const ref(&)**---->**变量**，***可以***，并且*无法通过ref进行修改*，但是可以直接修改变量  
    **ref(&)**--->**const 变量**，***不可以***  
    **const ref(&)**--->**const 变量**，***可以***  
    **ref(&)**--->**const ref(&)**，***不可以***  

### 进行赋值(=)操作时
+ 默认对右值进行一个**复制(copy)**，将**copy**赋予左值  
+ 因此即便写出这样的等式：
> (假定有一个c_ref，是const；和一个n_ref)  
> auto copy = ref;  

    这样得到的copy**并不是const**，**也不是ref**！  
> const auto c_copy = ref;//**const copy**  
> auto& ref = n_ref;//**ref**  
> const auto& ref = n_ref;//**const ref**  

+ ***由此可知，在进行=操作时，无论右值拥有怎样的特性，赋值给左值后只是一个普通的值，要想让左值有特性(const,&)，必须要手动在式子前面添加。***  
### const 与 ref(&) 使用
+ 当使用一些小型变量(int, double)时，**copy**即可  
+ 当需要对变量换个名字进行修改，用**ref**  
+ 当是一个大变量时且不需要修改（比如huge vector或自定义的结构体）时，选择**const ref**  

### 返回值也可以是ref、const ref
+ ～～没看懂～～